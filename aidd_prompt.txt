As an expert Flutter developer, I'm seeking your assistance with a multi-platform project called Colorpicker. This application is designed to function as a color selection tool, primarily for desktop environments (Mac, Windows, Linux), with an initial focus on macOS development.
      The key functionalities of the Colorpicker app include:
      - Background operation: The app should be accessible from the menu bar and offer an option to initiate a color picking session.
      - Color extraction: During a picking session, users should be able to select any point on the screen. The app must then capture the color information of the chosen pixel and present it in various formats, including RGB and HEX.
      - Magnification feature: The app should incorporate a magnifying glass tool to enlarge the area around the current mouse position.
      Your expertise in Flutter development is crucial for implementing these features and ensuring the app's compatibility across different desktop platforms, starting with macOS.

>>>>>>>>>>>>. Start lib/utils/color_utils.dart >>>>>>>>>>>>>>>>>
import 'package:flutter/material.dart';
import 'dart:math';

enum ColorFormat { sRGB, adobeRGB1998 }


class ColorUtils {
  static String rgbString(Color color) {
    return '${color.red}, ${color.green}, ${color.blue}';
  }

  static String hexString(Color color) {
    return '#${color.value.toRadixString(16).padLeft(8, '0').substring(2)}';
  }

  static String formatColor(Color color, ColorFormat format) {
    switch (format) {
      case ColorFormat.sRGB:
        return 'RGB(${color.red}, ${color.green}, ${color.blue})';
      case ColorFormat.adobeRGB1998:
        return adobeRGBString(color);
    }
  }

  static String adobeRGBString(Color color) {
    // Convert sRGB to XYZ
    List<double> xyz = _sRGBtoXYZ(color);

    // Convert XYZ to Adobe RGB
    List<double> adobeRGB = _XYZtoAdobeRGB(xyz);

    // Scale to 0-255 range and round
    int r = (adobeRGB[0] * 255).round().clamp(0, 255);
    int g = (adobeRGB[1] * 255).round().clamp(0, 255);
    int b = (adobeRGB[2] * 255).round().clamp(0, 255);

    return 'Adobe RGB($r, $g, $b)';
  }

  static List<double> _sRGBtoXYZ(Color color) {
    double r = _sRGBtoLinear(color.red / 255);
    double g = _sRGBtoLinear(color.green / 255);
    double b = _sRGBtoLinear(color.blue / 255);

    // sRGB to XYZ matrix (D65)
    double x = 0.4124564 * r + 0.3575761 * g + 0.1804375 * b;
    double y = 0.2126729 * r + 0.7151522 * g + 0.0721750 * b;
    double z = 0.0193339 * r + 0.1191920 * g + 0.9503041 * b;

    return [x, y, z];
  }

  static double _sRGBtoLinear(double c) {
    return c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4).toDouble();
  }

  static List<double> _XYZtoAdobeRGB(List<double> xyz) {
    // XYZ to Adobe RGB matrix (D65)
    double r =  2.0413690 * xyz[0] - 0.5649464 * xyz[1] - 0.3446944 * xyz[2];
    double g = -0.9692660 * xyz[0] + 1.8760108 * xyz[1] + 0.0415560 * xyz[2];
    double b =  0.0134474 * xyz[0] - 0.1183897 * xyz[1] + 1.0154096 * xyz[2];

    // Adobe RGB gamma correction
    r = _linearToAdobeRGB(r);
    g = _linearToAdobeRGB(g);
    b = _linearToAdobeRGB(b);

    return [r, g, b];
  }

  static double _linearToAdobeRGB(double c) {
    return pow(max(0, min(1, c)), 1 / 2.19921875).toDouble();
  }
}

>>>>>>>>>>>>. End lib/utils/color_utils.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start lib/screens/color_picker_screen.dart >>>>>>>>>>>>>>>>>
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:tray_manager/tray_manager.dart';
import 'package:window_manager/window_manager.dart';

import '../utils/color_utils.dart';
import '../widgets/color_display.dart';
import '../widgets/magnifier_view.dart';

class ColorPickerScreen extends StatefulWidget {
  const ColorPickerScreen({Key? key}) : super(key: key);

  @override
  _ColorPickerScreenState createState() => _ColorPickerScreenState();
}

class _ColorPickerScreenState extends State<ColorPickerScreen>
    with TrayListener {
  Color _pickedColor = Colors.white;
  bool _isPicking = false;
  ui.Image? _magnifiedImage;
  Offset _currentPosition = Offset.zero;
  List<Color> _savedColors = [];
  ColorFormat _selectedFormat = ColorFormat.sRGB;
  final MethodChannel _channel =
      MethodChannel('com.example.colorpicker/color_picker');

  @override
  void initState() {
    super.initState();
    _initTray();
    _channel.setMethodCallHandler(_handleMethodCall);
    windowManager.hide();
  }

  Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'colorUpdated':
        if (call.arguments is Map) {
          final Map<dynamic, dynamic> args =
              call.arguments as Map<dynamic, dynamic>;

          if (args.containsKey('color') &&
              args.containsKey('x') &&
              args.containsKey('y')) {
            final List<int> colorList = (args['color'] as List).cast<int>();
            final double x = args['x'] as double;
            final double y = args['y'] as double;

            setState(() {
              _pickedColor =
                  Color.fromRGBO(colorList[2], colorList[1], colorList[0], 1);
              _currentPosition = Offset(x, y);
            });
            await _updateMagnifiedImage(x, y);
          } else {
            print("Missing required keys in arguments");
          }
        } else {
          print("Arguments are not a Map: ${call.arguments.runtimeType}");
        }
        break;
      case 'colorSaved':
        if (call.arguments is Map) {
          final Map<dynamic, dynamic> args = call.arguments as Map<dynamic, dynamic>;
          if (args.containsKey('color')) {
            final List<int> colorList = (args['color'] as List).cast<int>();
            print("Add new color: ${colorList}");
            setState(() {
              _savedColors.add(Color.fromRGBO(colorList[2], colorList[1], colorList[0], 1));
            });
          }
        }
        break;
      default:
        print("Unhandled method: ${call.method}");
    }
  }

  Future<void> _updateMagnifiedImage(double x, double y) async {
    final result = await _channel.invokeMethod('getMagnifiedImage', {
      'x': x,
      'y': y,
    });

    if (result != null) {
      final bytes = result as Uint8List;
      final codec = await ui.instantiateImageCodec(bytes);
      final frame = await codec.getNextFrame();
      setState(() {
        _magnifiedImage = frame.image;
      });
    }
  }

  @override
  void onTrayIconMouseDown() async {
    bool isVisible = await windowManager.isVisible();
    if (isVisible) {
      await windowManager.hide();
    } else {
      await windowManager.show();
      await windowManager.focus();
    }
  }

  Future<void> _initTray() async {
    await trayManager.setIcon(
      'assets/app_icon.png',
      isTemplate: true,
    );
    Menu menu = Menu(
      items: [
        MenuItem(
          key: 'show_hide',
          label: 'Show/Hide',
        ),
        MenuItem(
          key: 'pick_color',
          label: 'Pick Color',
        ),
        MenuItem.separator(),
        MenuItem(
          key: 'quit',
          label: 'Quit',
        ),
      ],
    );
    await trayManager.setContextMenu(menu);
    trayManager.addListener(this);
  }

  @override
  void dispose() {
    trayManager.removeListener(this);
    super.dispose();
  }

  @override
  void onTrayMenuItemClick(MenuItem menuItem) async {
    switch (menuItem.key) {
      case 'show_hide':
        bool isVisible = await windowManager.isVisible();
        if (isVisible) {
          await windowManager.hide();
        } else {
          await windowManager.show();
          await windowManager.focus();
        }
        break;
      case 'pick_color':
        _startPickSession();
        break;
      case 'quit':
        await windowManager.close();
        break;
    }
  }

  void _startPickSession() async {
    setState(() {
      _isPicking = true;
    });
    try {
      final result = await _channel.invokeMethod('startColorPicking');
      setState(() {
        _pickedColor = Color.fromRGBO(result[0], result[1], result[2], 1);
        _isPicking = false;
      });
    } catch (e) {
      print('Error picking color: $e');
      setState(() {
        _isPicking = false;
      });
    }
  }

  void _stopPickSession() async {
    if (_isPicking) {
      await _channel.invokeMethod('stopColorPicking');
      setState(() {
        _isPicking = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ColorDisplay(color: _pickedColor, format: _selectedFormat),
            Text("X: ${_currentPosition.dx} Y: ${_currentPosition.dy}"),
            const SizedBox(height: 10),
            DropdownButton<ColorFormat>(
              value: _selectedFormat,
              onChanged: (ColorFormat? newValue) {
                setState(() {
                  _selectedFormat = newValue!;
                });
              },
              items: ColorFormat.values.map((ColorFormat format) {
                return DropdownMenuItem<ColorFormat>(
                  value: format,
                  child: Text(format.toString().split('.').last),
                );
              }).toList(),
            ),
            if (_isPicking && _magnifiedImage != null)
              MagnifierView(image: _magnifiedImage),
            ElevatedButton(
              onPressed: _isPicking ? _stopPickSession : _startPickSession,
              child: Text(_isPicking ? 'Stop Picking' : 'Start Picking'),
            ),

            SizedBox(
              height: 200,
              child: ListView.builder(
                itemCount: _savedColors.length,
                itemBuilder: (context, index) {
                  final color = _savedColors[index];
                  return ListTile(
                    leading: Container(
                      width: 30,
                      height: 30,
                      color: color,
                    ),
                    title: Text('R: ${color.red}, G: ${color.green}, B: ${color.blue}'),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

>>>>>>>>>>>>. End lib/screens/color_picker_screen.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start lib/main.dart >>>>>>>>>>>>>>>>>
import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';
import 'screens/color_picker_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = const WindowOptions(
    size: Size(300, 600),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Color Picker',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const ColorPickerScreen(),
    );
  }
}
>>>>>>>>>>>>. End lib/main.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start lib/widgets/magnifier_view.dart >>>>>>>>>>>>>>>>>
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import 'magnify_painter.dart';

class MagnifierView extends StatelessWidget {
  final ui.Image? image;

  const MagnifierView({Key? key, this.image}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (image == null) return const SizedBox();

    return Container(
      width: 100,
      height: 100,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black, width: 2),
      ),
      child: CustomPaint(
        painter: MagnifyPainter(image!),
      ),
    );
  }
}

>>>>>>>>>>>>. End lib/widgets/magnifier_view.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start lib/widgets/magnify_painter.dart >>>>>>>>>>>>>>>>>
import 'package:flutter/material.dart';
import 'dart:ui' as ui;

class MagnifyPainter extends CustomPainter {
  final ui.Image image;

  MagnifyPainter(this.image);

  @override
  void paint(Canvas canvas, Size size) {
    final src = Rect.fromLTWH(0, 0, image.width.toDouble(), image.height.toDouble());
    final dst = Rect.fromLTWH(0, 0, size.width, size.height);
    canvas.drawImageRect(image, src, dst, Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

>>>>>>>>>>>>. End lib/widgets/magnify_painter.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start lib/widgets/color_display.dart >>>>>>>>>>>>>>>>>
import 'package:flutter/material.dart';
import '../utils/color_utils.dart';

class ColorDisplay extends StatelessWidget {
  final Color color;
  final ColorFormat format;

  const ColorDisplay({Key? key, required this.color, required this.format}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(8),
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Container(
            width: 100,
            height: 100,
            color: color,
          ),
          Text(ColorUtils.formatColor(color, format)),
        ],
      ),
    );
  }
}
>>>>>>>>>>>>. End lib/widgets/color_display.dart >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start macos/Runner/AppDelegate.swift >>>>>>>>>>>>>>>>>
import Cocoa
import FlutterMacOS
import Foundation

@NSApplicationMain
class AppDelegate: FlutterAppDelegate {
    private var colorPicker: ColorPicker?
    private var channel: FlutterMethodChannel?
    
    override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return false
    }

    override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
        return true
    }

    override func applicationDidFinishLaunching(_ notification: Notification) {
        let controller = mainFlutterWindow?.contentViewController as! FlutterViewController
        channel = FlutterMethodChannel(name: "com.example.colorpicker/color_picker", binaryMessenger: controller.engine.binaryMessenger)

        colorPicker = ColorPicker()

        channel?.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: @escaping FlutterResult) in
            guard let self = self else { return }

            switch call.method {
            case "startColorPicking":
                self.colorPicker?.startColorPicking(result: result)
            case "stopColorPicking":
                self.colorPicker?.stopColorPicking()
            case "getMagnifiedImage":
                if let args = call.arguments as? [String: Any],
                   let x = args["x"] as? CGFloat,
                   let y = args["y"] as? CGFloat {
                    self.colorPicker?.getMagnifiedImage(x: x, y: y, result: result)
                } else {
                    result(FlutterError(code: "INVALID_ARGUMENTS", message: "Invalid arguments", details: nil))
                }
                case "saveCurrentColor":
                    self.colorPicker?.saveCurrentColor()
                    result(nil)

            default:
                result(FlutterMethodNotImplemented)
            }
        }

        NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
            if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "l" {
                self.colorPicker?.saveCurrentColor()
            }
            return event
        }

        NotificationCenter.default.addObserver(forName: NSNotification.Name("ColorUpdated"), object: nil, queue: .main) { [weak self] notification in
            if let userInfo = notification.userInfo,
               let color = userInfo["color"] as? [Int],
               let x = userInfo["x"] as? CGFloat,
               let y = userInfo["y"] as? CGFloat {
                self?.channel?.invokeMethod("colorUpdated", arguments: [
                    "color": color,
                    "x": x,
                    "y": y
                ])
            }
        }

        NotificationCenter.default.addObserver(forName: NSNotification.Name("ColorSaved"), object: nil, queue: .main) { [weak self] notification in
            if let userInfo = notification.userInfo,
               let color = userInfo["color"] as? [Int] {
                self?.channel?.invokeMethod("colorSaved", arguments: [
                    "color": color
                ])
            }
        }


        requestScreenCaptureAccess()
    }

    private func requestScreenCaptureAccess() {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
        let accessEnabled = AXIsProcessTrustedWithOptions(options)

        if !accessEnabled {
            let alert = NSAlert()
            alert.messageText = "Screen Recording Permission Required"
            alert.informativeText = "This app needs screen recording permission to pick colors. Please grant permission in System Preferences > Security & Privacy > Privacy > Screen Recording."
            alert.alertStyle = .warning
            alert.addButton(withTitle: "Open System Preferences")
            alert.addButton(withTitle: "Cancel")

            let response = alert.runModal()
            if response == .alertFirstButtonReturn {
                NSWorkspace.shared.open(URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture")!)
            }
        }
    }
}

>>>>>>>>>>>>. End macos/Runner/AppDelegate.swift >>>>>>>>>>>>>>>>>

>>>>>>>>>>>>. Start macos/Runner/ColorPicker.swift >>>>>>>>>>>>>>>>>
import Cocoa
import FlutterMacOS

@objc class ColorPicker: NSObject {
    private var isTracking = false
    private var trackingTimer: Timer?
    private var flutterResult: FlutterResult?
    private var lastColor: NSColor?

    @objc func startColorPicking(result: @escaping FlutterResult) {
        isTracking = true
        flutterResult = result
        startTracking()
    }

    @objc func getMagnifiedImage(x: CGFloat, y: CGFloat, result: @escaping FlutterResult) {
        guard let mainScreen = NSScreen.main else {
          assertionFailure()
          return
        }
        let size: CGFloat = 13 // Size of the magnified area
        let flippedY = mainScreen.frame.height - y
        if let screenWithMouse = NSScreen.screens.first(where: { NSMouseInRect(NSPoint(x: x, y: flippedY), $0.frame, false) }) {
            let rectX = max(0, min(x - size/2, screenWithMouse.frame.width - size))
            let rectY = max(0, min(flippedY - size/2, screenWithMouse.frame.height - size))

            let rect = CGRect(x: rectX, y: rectY, width: size, height: size)

            let image = CGWindowListCreateImage(
                rect,
                .optionOnScreenOnly,
                kCGNullWindowID,
                .bestResolution
            )

            if let image = image {
                let nsImage = NSImage(cgImage: image, size: NSSize(width: size, height: size))
                if let tiffData = nsImage.tiffRepresentation,
                   let bitmapImage = NSBitmapImageRep(data: tiffData),
                   let pngData = bitmapImage.representation(using: .png, properties: [:]) {
                    result(FlutterStandardTypedData(bytes: pngData))
                } else {
                    result(FlutterError(code: "FAILED", message: "Failed to create image data", details: nil))
                }
            } else {
                result(FlutterError(code: "FAILED", message: "Failed to capture screen", details: nil))
            }
        } else {
            result(FlutterError(code: "FAILED", message: "Screen not found", details: nil))
        }
    }

    @objc func saveCurrentColor() {
        if let color = lastColor {
            let red = Int(color.redComponent * 255)
            let green = Int(color.greenComponent * 255)
            let blue = Int(color.blueComponent * 255)
            NotificationCenter.default.post(name: NSNotification.Name("ColorSaved"), object: nil, userInfo: [
                "color": [red, green, blue]
            ])
        }
    }

    private func startTracking() {
        trackingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            self?.updateColorAtMousePosition()}
    }

    private func updateColorAtMousePosition() {
        let mouseLocation = NSEvent.mouseLocation
        if let screenWithMouse = NSScreen.screens.first(where: { NSMouseInRect(mouseLocation, $0.frame, false) }),
           let color = getColorAtPosition(mouseLocation, on: screenWithMouse) {
           lastColor = color

            let red = Int(color.redComponent * 255)
            let green = Int(color.greenComponent * 255)
            let blue = Int(color.blueComponent * 255)
            NotificationCenter.default.post(name: NSNotification.Name("ColorUpdated"), object: nil, userInfo: [
                "color": [red, green, blue],
                "x": mouseLocation.x,
                "y": mouseLocation.y
            ])
        }
    }

    private func getColorAtPosition(_ position: NSPoint, on screen: NSScreen) -> NSColor? {
        let image = CGWindowListCreateImage(
            CGRect(x: position.x, y: screen.frame.height - position.y, width: 1, height: 1),
            .optionOnScreenOnly,
            kCGNullWindowID,
            .bestResolution
        )
        if let image = image {
            let nsImage = NSImage(cgImage: image, size: NSSize(width: 1, height: 1))
            return nsImage.color(at: NSPoint(x: 0, y: 0))?.usingColorSpace(.sRGB)
        }
        return nil
    }

    @objc func stopColorPicking() {
        isTracking = false
        trackingTimer?.invalidate()
        trackingTimer = nil
        if let color = getColorAtMousePosition() {
            let red = Int(color.redComponent * 255)
            let green = Int(color.greenComponent * 255)
            let blue = Int(color.blueComponent * 255)
            flutterResult?([red, green, blue])
        } else {
            flutterResult?(FlutterError(code: "FAILED", message: "Failed to get color", details: nil))
        }
        flutterResult = nil
    }

    private func getColorAtMousePosition() -> NSColor? {
        let mouseLocation = NSEvent.mouseLocation
        if let screenWithMouse = NSScreen.screens.first(where: { NSMouseInRect(mouseLocation, $0.frame, false) }) {
            let image = CGWindowListCreateImage(
                CGRect(x: mouseLocation.x, y: screenWithMouse.frame.height - mouseLocation.y, width: 1, height: 1),
                .optionOnScreenOnly,
                kCGNullWindowID,
                .bestResolution
            )
            if let image = image {
                let nsImage = NSImage(cgImage: image, size: NSSize(width: 1, height: 1))
                if let color = nsImage.color(at: NSPoint(x: 0, y: 0)) {
                    return color.usingColorSpace(.sRGB) ?? color
                }
            }
        }
        return nil
    }
}

extension NSImage {
    func color(at point: NSPoint) -> NSColor? {
        guard let cgImage = self.cgImage(forProposedRect: nil, context: nil, hints: nil) else { return nil }
        let pixelData = cgImage.dataProvider!.data
        let data: UnsafePointer<UInt8> = CFDataGetBytePtr(pixelData)
        let pixelInfo: Int = ((Int(self.size.width) * Int(point.y)) + Int(point.x)) * 4
        let r = CGFloat(data[pixelInfo]) / CGFloat(255.0)
        let g = CGFloat(data[pixelInfo+1]) / CGFloat(255.0)
        let b = CGFloat(data[pixelInfo+2]) / CGFloat(255.0)
        let a = CGFloat(data[pixelInfo+3]) / CGFloat(255.0)
        return NSColor(red: r, green: g, blue: b, alpha: a)
    }
}
>>>>>>>>>>>>. End macos/Runner/ColorPicker.swift >>>>>>>>>>>>>>>>>

Read the source code carefully, then stand by for my request\n
My rule - Important: Only print the code changes in you output\n
